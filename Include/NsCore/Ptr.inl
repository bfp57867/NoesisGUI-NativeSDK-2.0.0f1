////////////////////////////////////////////////////////////////////////////////////////////////////
// Noesis Engine - http://www.noesisengine.com
// Copyright (c) 2009-2010 Noesis Technologies S.L. All Rights Reserved.
// [CR #629]
////////////////////////////////////////////////////////////////////////////////////////////////////


#include <NsCore/Error.h>


namespace Noesis
{
namespace Core
{

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T> 
Ptr<T>::Ptr(): mPtr(0) {}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T> 
    Ptr<T>::Ptr(std::nullptr_t): mPtr(0) {}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T> 
Ptr<T>::Ptr(T* ptr): mPtr(ptr)
{
    if (mPtr != 0)
    {
        mPtr->AddReference();
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
Ptr<T>::Ptr(T& ptr): mPtr(&ptr) {}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
Ptr<T>::Ptr(const Ptr& ptr): mPtr(ptr.mPtr)
{
    if (mPtr != 0)
    {
        mPtr->AddReference();
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
template<class S> Ptr<T>::Ptr(const Ptr<S>& ptr): mPtr(ptr.GetPtr())
{
    if (mPtr != 0)
    {
        mPtr->AddReference();
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
Ptr<T>::Ptr(Ptr&& ptr): mPtr(ptr.mPtr)
{
    ptr.GiveOwnership();
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
template<class S> Ptr<T>::Ptr(Ptr<S>&& ptr): mPtr(ptr.GetPtr())
{
    ptr.GiveOwnership();
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
Ptr<T>::~Ptr()
{
    if (mPtr != 0)
    {
        mPtr->Release();
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
Ptr<T>& Ptr<T>::operator=(const Ptr& ptr)
{
    Reset(ptr.mPtr);
    return *this;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
template<class S> Ptr<T>& Ptr<T>::operator=(const Ptr<S>& ptr)
{
    Reset(ptr.GetPtr());
    return *this;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
Ptr<T>& Ptr<T>::operator=(Ptr&& ptr)
{
    if (mPtr != ptr.mPtr)
    {
        if (mPtr != 0)
        {
            mPtr->Release();
        }

        mPtr = ptr.mPtr;
        ptr.GiveOwnership();
    }

    return *this;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
template<class S> Ptr<T>& Ptr<T>::operator=(Ptr<S>&& ptr)
{
    // GiveOwnership() done at the beginning to avoid a bug in MSVC2015 Update3 when compiling with 
    // Whole Program Optimization and Omit Frame Pointers enabled
    S* obj = ptr.GetPtr();
    ptr.GiveOwnership();

    if (mPtr != 0)
    {
        mPtr->Release();
    }

    mPtr = obj;
    return *this;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
Ptr<T>& Ptr<T>::operator=(T& ptr)
{
    if (mPtr != &ptr)
    {
        if (mPtr != 0)
        {
            mPtr->Release();
        }

        mPtr = &ptr;
    }

    return *this;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
void Ptr<T>::Reset()
{
    if (mPtr != 0)
    {
        mPtr->Release();
    }

    mPtr = 0;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
void Ptr<T>::Reset(T* ptr)
{
    if (mPtr != ptr)
    {
        if (ptr != 0)
        {
            ptr->AddReference();
        }
        
        if (mPtr != 0)
        {
            mPtr->Release();
        }

        mPtr = ptr;
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
T* Ptr<T>::GiveOwnership()
{
    T* ptr = mPtr;
    mPtr = 0;
    return ptr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
T* Ptr<T>::operator->() const
{
    NS_ASSERT(mPtr != 0);
    return mPtr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
T* Ptr<T>::GetPtr() const
{
    return mPtr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
Ptr<T>::operator bool() const
{
    return mPtr != 0;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
template<class S> bool Ptr<T>::operator==(const Ptr<S>& ptr) const
{
    return mPtr == ptr.GetPtr();
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
template<class S> bool Ptr<T>::operator!=(const Ptr<S>& ptr) const
{
   return mPtr != ptr.GetPtr();
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
template<class S> bool Ptr<T>::operator<(const Ptr<S>& ptr) const
{
    return mPtr < ptr.GetPtr();
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
template<class S> bool Ptr<T>::operator==(S* ptr) const
{
    return mPtr == ptr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
template<class S> bool Ptr<T>::operator!=(S* ptr) const
{
    return mPtr != ptr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
template<class S> bool Ptr<T>::operator<(S* ptr) const
{
    return mPtr < ptr;
}

}
}
